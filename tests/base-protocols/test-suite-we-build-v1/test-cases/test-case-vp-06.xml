<testcase id="tc014" xmlns="http://www.gitb.com/tdl/v1/" xmlns:gitb="http://www.gitb.com/core/v1/"
>
    <metadata>
        <gitb:name>Test Case VP-006: WE BUILD - DCQL-based Verifiable Presentation request for
            urn:eu.europa.ec.eudi:pid:1 with family_name claim using using DID Web client_id_scheme with direct_post
            response mode and GET method for request URI.
        </gitb:name>
        <gitb:version>1.0</gitb:version>
        <gitb:description>Test integration of Wallet with WE BUILD reference implementation.
            DCQL-based Verifiable Presentation request using DID Web client_id_scheme with direct_post response mode and
            GET method for request URI. query (urn:eu.europa.ec.eudi:pid:1 with family_name claim).
            The verifier uses DID Web identification (decentralized_identifier:did:web:{controller}) and signs the VP
            request JWT with a private key (kid: did:web:{controller}#keys-1). The wallet fetches the VP request JWT via
            GET (instead of POST) from the request_uri endpoint. The wallet can verify the VP request signature by
            resolving the DID document from /.well-known/did.json and using the public key from the verification method.
            Wallet responds with VP token via POST to /direct_post/{sessionId}. The verifier performs comprehensive
            verification including: (1) State parameter validation - ensures state matches the session to prevent replay
            attacks; (2) Nonce verification - validates nonce from key-binding JWT (for SD-JWT) or VP token payload
            matches the challenge nonce; (3) Key-binding JWT verification - for SD-JWT credentials, extracts and
            validates the key-binding JWT signature, verifies audience (aud) matches verifier's DID client_id, and
            ensures the key-binding JWT contains the required nonce; (4) Credential signature verification - validates
            issuer signatures on SD-JWT or JWT VC credentials using issuer JWKS or x5c certificates; (5) Holder binding
            verification - verifies the key-binding JWT public key (from cnf.jwk) matches the wallet's presentation key,
            ensuring proof of possession; (6) Selective disclosure validation - ensures only requested claims (per DCQL
            query) are disclosed; (7) Credential type validation - verifies presented credentials match requested types
            (vct/doctype); (8) VP request JWT signature verification - wallet verifies the VP request JWT signature
            using the public key from the DID document, ensuring the request is authentic and unmodified; (9) Request
            URI method - wallet fetches VP request using GET method (no request_uri_method=post parameter in the
            OpenID4VP URL).
            DCQL-based Verifiable Presentation request using DID JWK client_id_scheme with direct_post response mode.
            DCQL query (urn:eu.europa.ec.eudi:pid:1 with family_name claim).
            The verifier uses DID JWK identification (decentralized_identifier:did:jwk:{base64url-encoded-jwk}) where
            the public key is embedded directly in the DID identifier itself, eliminating the need for DID document
            resolution. The VP request JWT is signed with a private key (kid: did:jwk:{base64url-encoded-jwk}#0). The
            wallet can verify the VP request signature by extracting the public key directly from the DID identifier
            (base64url decoding the JWK portion), without requiring HTTP resolution of a DID document. Wallet responds
            with VP token via POST to /direct_post/{sessionId}. The verifier performs comprehensive verification
            including: (1) State parameter validation - ensures state matches the session to prevent replay attacks; (2)
            Nonce verification - validates nonce from key-binding JWT (for SD-JWT) or VP token payload matches the
            challenge nonce; (3) Key-binding JWT verification - for SD-JWT credentials, extracts and validates the
            key-binding JWT signature, verifies audience (aud) matches verifier's DID JWK client_id, and ensures the
            key-binding JWT contains the required nonce; (4) Credential signature verification - validates issuer
            signatures on SD-JWT or JWT VC credentials using issuer JWKS or x5c certificates; (5) Holder binding
            verification - verifies the key-binding JWT public key (from cnf.jwk) matches the wallet's presentation key,
            ensuring proof of possession; (6) Selective disclosure validation - ensures only requested claims (per DCQL
            query) are disclosed; (7) Credential type validation - verifies presented credentials match requested types
            (vct/doctype); (8) VP request JWT signature verification - wallet verifies the VP request JWT signature by
            extracting the public key directly from the DID JWK identifier (base64url decoding the JWK portion),
            ensuring the request is authentic and unmodified without requiring network resolution
        </gitb:description>
        <!-- See here how we refer to a HTML block that will be added as documentation for the test case. -->
        <gitb:documentation import="/docs/test-case-1.html"/>
    </metadata>
    <actors>
        <!--
            The Actor IDs need to match those in the test suite and in the test engine. One of these needs to always be the SUT (System Under Test).
        -->
        <gitb:actor id="User" role="SUT"/>
        <gitb:actor id="Verifier"/>
    </actors>
    <!-- 
        Setting "stopOnError" to true will stop the test session as soon as an error is encountered. By default test sessions will continue regardless of errors.
    -->
    <steps stopOnError="false">
        <!--
            The "call" step is used to use a scriptlet, which is the GITB TDL's construct for a reusable block of steps.
            Anything that repeats can be defined as a scriptlet and reused like this. You can also parameterise its use
            through the inputs you pass it.
        -->
        <call id="issue" path="/scriptlets/vp-06.xml">
            <input name="credentialType">"urn:eu.europa.ec.eudi:pid:1"</input>
        </call>
    </steps>
    <!-- The output section allows us to define specialised summary error (or success) messages to make the result more user-friendly. -->
    <output>
        <success>
            <default>"Test case completed successfully."</default>
        </success>
        <failure>
            <case>
                <!--
                    Notice how we use the built-in "STEP_STATUS" map to lookup the status of steps by their ID.
                    To check steps defined within scriptlets you prefix the step ID by the scriptlet call step's ID (separated by an underscore).
                -->
                <cond>$STEP_STATUS{authenticate_step1} = 'ERROR'</cond>
                <message>"The credential request was not completed successfully. Please check the failed step's report
                    for more information and the test log."
                </message>
            </case>
            <case>
                <cond>$STEP_STATUS{authenticate_getValidationResponse} = 'ERROR'</cond>
                <message>"A completed validation response was not received within the expected time limit."</message>
            </case>
            <case>
                <cond>$STEP_STATUS{authenticate_step2} = 'ERROR'</cond>
                <message>"The validation response was not completed successfully. Please check the failed step's report
                    for more information and the test log."
                </message>
            </case>
            <!-- If no specific case is matched print a default message. -->
            <default>"Test case failed. Please check the failed step's report for more information and the test log."
            </default>
        </failure>
    </output>
</testcase>